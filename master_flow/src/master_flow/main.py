#!/usr/bin/env python
import json
import sys
from crewai.flow.flow import Flow, start, listen, router, or_
from crewai.flow.persistence import persist

# Import the SystemState from the model folder
from master_flow.model.system_state import SystemState

# Import the crews
from master_flow.crews.macro_planning_crew.macro_crew import MacroPlanningCrew
from master_flow.crews.micro_learning_crew.micro_crew import MicroLearningCrew

@persist()
class MasterFlow(Flow[SystemState]):
    
    @start()
    def execute_macro_planning(self):
        print(f"--- MACRO PLANNING CREW ACTIVATED ---")
        
        inputs = {
            "topic": self.state.topic,
            "experience": self.state.experience,
            "goal": self.state.goal,
            "constraints": self.state.constraints or "None specified."
        }
        
        # Kickoff the Crew. Runs Architect only now.
        macro_crew = MacroPlanningCrew().crew()
        result = macro_crew.kickoff(inputs=inputs)
        
        print("DEBUG RESULT:", dir(result))
        print("DEBUG RAW:", getattr(result, "raw", None))
        print("DEBUG PYDANTIC:", getattr(result, "pydantic", None))
        print("DEBUG JSON_DICT:", getattr(result, "json_dict", None))
        if hasattr(result, "tasks_output") and result.tasks_output:
            print("DEBUG TASK 0 PYDANTIC:", getattr(result.tasks_output[0], "pydantic", None))
            print("DEBUG TASK 0 JSON_DICT:", getattr(result.tasks_output[0], "json_dict", None))

        # It's better to get the task output directly since we defined output_pydantic:
        try:
            blueprint_draft = result.pydantic
            if blueprint_draft:
                self.state.blueprint = blueprint_draft.model_dump()
            else:
                self.state.blueprint = {"nodes": []}
        except Exception as e:
            print(f"Warning: Could not extract architect blueprint. {e}")
            self.state.blueprint = {"nodes": []}

        print("--- BLUEPRINT GENERATED BY ARCHITECT ---")

    @listen(execute_macro_planning)
    def prepare_micro_loop(self):
        """Extracts the nodes from the blueprint to prepare for the micro-research loop."""
        blueprint_data = self.state.blueprint # This is the dict saved from Macro Crew
        self.state.pending_nodes = blueprint_data.get("nodes", [])
        self.state.completed_modules = []

    @listen("process_single_node")
    def process_node(self):
        """Pops one node off the list and runs the Micro Crew on it."""
        current_node = self.state.pending_nodes.pop(0)
        print(f"--- GENERATING CONTENT FOR: {current_node['title']} ---")
        
        inputs = {
            "macro_title": current_node['title'],
            "node_id": current_node['node_id'],
            "micro_topics_list": ", ".join(current_node['suggested_micro_topics']),
            "experience": self.state.experience,
            "goal": self.state.goal
        }
        
        # Kickoff the Scraper -> Educator -> Estimator pipeline
        result = MicroLearningCrew().crew().kickoff(inputs=inputs)
        node_content = result.pydantic
        
        # Save the generated content
        if node_content:
            self.state.completed_modules.append(node_content.model_dump())
        else:
            print(f"Warning: No valid pydantic output from Micro Crew for {current_node['title']}")

    @router(or_(prepare_micro_loop, process_node))
    def route_micro_crew(self):
        """The Gatekeeper for the Micro-Learning Loop."""
        if len(self.state.pending_nodes) > 0:
            return "process_single_node"
        else:
            return "course_generation_complete"

    @listen("course_generation_complete")
    def finish_course(self):
        reply = "Your complete, personalized micro-learning course is ready!"
        self.state.chat_history.append({"role": "assistant", "content": reply})
        return {
            "status": "complete", 
            "reply": reply, 
            "blueprint": self.state.blueprint,
            "course_content": self.state.completed_modules
        }

def kickoff():
    master_flow = MasterFlow()
    master_flow.kickoff()

def plot():
    master_flow = MasterFlow()
    master_flow.plot()

if __name__ == "__main__":
    kickoff()
